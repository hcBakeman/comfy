<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comfy Engine | Wallpaper / Scene tool</title>
    <style>
        :root { --bg: #000; --ui-accent: #ff4400; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-container, #main-hint { opacity: 0; pointer-events: none; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
        #ui-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(20px);
            z-index: 10; background: rgba(10, 10, 10, 0.85); backdrop-filter: blur(25px);
            padding: 20px 30px; border-radius: 25px; border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; gap: 12px; min-width: 340px;
        }
        #ui-container.visible, #main-hint.visible { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: all; }
        #main-hint.visible { opacity: 0.4; }
        #main-hint { position: absolute; top: 20px; left: 50%; transform: translateX(-50%) translateY(-20px); font-size: 11px; letter-spacing: 2px; text-transform: uppercase; z-index: 5; }
        .mode-selector { display: flex; justify-content: center; gap: 8px; margin-bottom: 5px; flex-wrap: wrap; }
        button { background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); border: 1px solid rgba(255,255,255,0.1); padding: 8px 12px; border-radius: 12px; cursor: pointer; font-size: 10px; font-weight: 700; text-transform: uppercase; transition: 0.3s; }
        button.active { background: var(--ui-accent); color: white; border-color: var(--ui-accent); box-shadow: 0 0 15px var(--ui-accent); }
        .control-row { display: flex; flex-direction: column; gap: 4px; }
        .control-row label { font-size: 9px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; }
        
        select { 
            background: #111; color: #fff; border: 1px solid rgba(255,255,255,0.2); 
            border-radius: 8px; font-size: 10px; padding: 6px; outline: none; cursor: pointer;
            text-transform: uppercase; font-weight: bold;
        }

        input[type=range] { appearance: none; width: 100%; height: 3px; background: rgba(255,255,255,0.1); outline: none; }
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: #fff; border-radius: 50%; cursor: pointer; }
        .hue-slider { background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%) !important; }
        
        .switch-container { display: flex; align-items: center; justify-content: space-between; margin-top: 5px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        .switch { position: relative; display: inline-block; width: 30px; height: 16px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 10px; width: 10px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--ui-accent); }
        
        .mouse-setting, .fire-setting { display: none; }
        .mouse-enabled .mouse-setting { display: flex; }
        .fire-enabled .fire-setting { display: flex; }
    </style>
</head>
<body class="mouse-enabled">

    <div id="main-hint">M = Toggle Menu | Link saves settings</div>
    <canvas id="canvas"></canvas>

    <div id="ui-container">
        <div class="mode-selector">
            <button onclick="updateVisualMood('hearts')" id="btn-hearts">Hearts</button>
            <button onclick="updateVisualMood('bubbles')" id="btn-bubbles">Bubbles</button>
            <button onclick="updateVisualMood('bloom')" id="btn-bloom">Spirit Bloom</button>
            <button onclick="updateVisualMood('fire')" id="btn-fire">Fire</button>
            <button onclick="updateVisualMood('rain')" id="btn-rain">Rain</button>
        </div>
        
        <div class="control-row"><label>Intensity: <span id="val-count"></span></label><input type="range" id="input-count" min="1" max="500"></div>
        <div class="control-row"><label>Speed: <span id="val-speed"></span></label><input type="range" id="input-speed" min="0.1" max="15" step="0.1"></div>
        <div class="control-row"><label>Size: <span id="val-size"></span></label><input type="range" id="input-size" min="1" max="250"></div>
        <div class="control-row"><label>Hue: <span id="val-hue"></span></label><input type="range" id="input-hue" class="hue-slider" min="0" max="360" step="1"></div>
        
        <div class="control-row"><label>Flicker Power: <span id="val-flickerStr"></span></label><input type="range" id="input-flickerStr" min="0" max="1" step="0.05"></div>
        <div class="control-row"><label>Flicker Time: <span id="val-flickerSpeed"></span></label><input type="range" id="input-flickerSpeed" min="0.01" max="0.5" step="0.01"></div>

        <div class="control-row mouse-setting">
            <label>Avoid Radius: <span id="val-mradius"></span></label>
            <input type="range" id="input-mradius" min="10" max="500" step="10">
        </div>

        <div class="control-row fire-setting">
            <label>Fire Style</label>
            <select id="input-fstyle">
                <option value="poly">Polygonal</option>
                <option value="fluid">Fluid Wisps</option>
            </select>
        </div>

        <div class="switch-container mouse-setting" style="border-top: none; padding-top: 0; margin-top: -5px;">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8; color: #00ffcc;">Mouse Interact</label>
            <label class="switch"><input type="checkbox" id="input-mousehit"><span class="slider"></span></label>
        </div>

        <div class="switch-container">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8;">Auto Hue</label>
            <label class="switch"><input type="checkbox" id="input-autohue"><span class="slider"></span></label>
        </div>

        <div class="switch-container">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8;">Flicker Glow</label>
            <label class="switch"><input type="checkbox" id="input-glow"><span class="slider"></span></label>
        </div>
        <div class="switch-container" style="border-top: none; margin-top: 0; padding-top: 0;">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8;">Smooth Physics</label>
            <label class="switch"><input type="checkbox" id="input-physics"><span class="slider"></span></label>
        </div>
    </div>

    <script>
        const renderCanvas = document.getElementById('canvas');
        const drawContext = renderCanvas.getContext('2d');
        const uiPanel = document.getElementById('ui-container');
        const uiHint = document.getElementById('main-hint');
        let viewWidth, viewHeight, elementArray = [], animationTime = 0;
        let mousePosition = { x: -2000, y: -2000 };

        const queryParams = new URLSearchParams(window.location.search);
        
        // S-Tier Default Landing Page Configuration
        let engineConfig = {
            mood: queryParams.get('m') || 'hearts',
            count: parseInt(queryParams.get('c')) || 57,
            speed: parseFloat(queryParams.get('s')) || 2.0,
            size: parseInt(queryParams.get('z')) || 250,
            hue: parseInt(queryParams.get('h')) || 345,
            autohue: queryParams.get('ah') === '1',
            glow: queryParams.get('g') !== '0',
            physics: queryParams.get('p') !== '0',
            uiVisible: queryParams.get('u') !== '0', // Default changed to TRUE (per ?u=1)
            mousehit: queryParams.get('mh') === '1',
            mradius: parseInt(queryParams.get('mr')) || 10,
            fstyle: queryParams.get('fst') || 'poly',
            flickerStr: parseFloat(queryParams.get('fs')) || 0.3,
            flickerSpeed: parseFloat(queryParams.get('fsp')) || 0.1
        };

        window.addEventListener('mousemove', (e) => { mousePosition.x = e.clientX; mousePosition.y = e.clientY; });

        function synchronizeUrlParameters() {
            const params = new URLSearchParams();
            params.set('m', engineConfig.mood); params.set('c', engineConfig.count); params.set('s', engineConfig.speed);
            params.set('z', engineConfig.size); params.set('h', Math.floor(engineConfig.hue)); 
            params.set('ah', engineConfig.autohue ? '1' : '0'); params.set('g', engineConfig.glow ? '1' : '0'); 
            params.set('p', engineConfig.physics ? '1' : '0'); params.set('u', engineConfig.uiVisible ? '1' : '0');
            params.set('mh', engineConfig.mousehit ? '1' : '0'); params.set('mr', engineConfig.mradius); 
            params.set('fst', engineConfig.fstyle); params.set('fs', engineConfig.flickerStr); params.set('fsp', engineConfig.flickerSpeed);
            window.history.replaceState(null, '', window.location.pathname + '?' + params.toString());
        }

        class VisualElement {
            constructor(isInitialBatch = false) { this.resetState(isInitialBatch); }
            resetState(randomPlacement = false) {
                this.posX = Math.random() * viewWidth;
                this.posY = randomPlacement ? Math.random() * viewHeight : (engineConfig.mood === 'rain' ? -100 : viewHeight + 250);
                this.radius = Math.random() * engineConfig.size * 0.5 + 10;
                this.cyclePhase = Math.random() * Math.PI * 2;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationVelocity = (Math.random() - 0.5) * 0.05;
                this.hueVariation = (Math.random() - 0.5) * 60;
                this.driftFactor = 0.5 + Math.random(); 
                this.baseVelX = (Math.random() - 0.5) * 0.5 * this.driftFactor;
                this.baseVelY = engineConfig.mood === 'rain' ? (Math.random() * 5 + 5) : -(Math.random() * 0.5 + 0.3) * this.driftFactor;
                this.currentVelX = this.baseVelX; this.currentVelY = this.baseVelY;
            }
            updatePhysics() {
                if (engineConfig.physics && ['hearts', 'bubbles', 'fire', 'bloom'].includes(engineConfig.mood)) {
                    for (let other of elementArray) {
                        if (this === other) continue;
                        let dx = other.posX - this.posX, dy = other.posY - this.posY;
                        let minDist = (this.radius + other.radius) * 0.45;
                        if (Math.abs(dx) < minDist && Math.abs(dy) < minDist) {
                            let distSq = dx*dx + dy*dy;
                            if (distSq < minDist * minDist && distSq > 0) {
                                let dist = Math.sqrt(distSq);
                                let angle = Math.atan2(dy, dx);
                                let pushX = Math.cos(angle) * 0.05;
                                let pushY = Math.sin(angle) * 0.05;
                                this.currentVelX -= pushX; this.currentVelY -= pushY;
                                other.currentVelX += pushX; other.currentVelY += pushY;
                            }
                        }
                    }
                    this.currentVelX *= 0.98; this.currentVelY *= 0.98;
                }

                if (engineConfig.mousehit && ['hearts', 'bubbles', 'bloom'].includes(engineConfig.mood)) {
                    let dxM = this.posX - mousePosition.x; let dyM = this.posY - mousePosition.y;
                    let distSqM = dxM*dxM + dyM*dyM;
                    if (distSqM < engineConfig.mradius * engineConfig.mradius) {
                        let distM = Math.sqrt(distSqM);
                        let force = (engineConfig.mradius - distM) / engineConfig.mradius;
                        let angle = Math.atan2(dyM, dxM);
                        this.currentVelX += Math.cos(angle) * force * 1.2;
                        this.currentVelY += Math.sin(angle) * force * 1.2;
                    }
                }

                this.currentVelX += (this.baseVelX - this.currentVelX) * 0.02;
                this.currentVelY += (this.baseVelY - this.currentVelY) * 0.02;
                this.posX += this.currentVelX * engineConfig.speed;
                this.posY += this.currentVelY * engineConfig.speed;
                this.rotation += this.rotationVelocity * (engineConfig.speed * 0.5);

                if (this.posY < -500 || this.posY > viewHeight + 500 || this.posX < -500 || this.posX > viewWidth + 500) this.resetState();
            }
            renderToCanvas() {
                const drawLimit = this.radius * 2.5;
                if (this.posX < -drawLimit || this.posX > viewWidth + drawLimit || this.posY < -drawLimit || this.posY > viewHeight + drawLimit) return;

                drawContext.save();
                const intensityOffset = 1 - engineConfig.flickerStr;
                const flickerValue = engineConfig.glow ? (intensityOffset + Math.sin(animationTime * engineConfig.flickerSpeed + this.cyclePhase) * engineConfig.flickerStr) : 1;
                const activeHue = engineConfig.hue + this.hueVariation;
                if (engineConfig.glow) drawContext.globalCompositeOperation = 'lighter';
                
                if (engineConfig.mood === 'bloom') {
                    drawContext.translate(this.posX, this.posY); drawContext.rotate(this.rotation + animationTime * 0.005);
                    const coreR = this.radius * 0.8;
                    if (engineConfig.glow) {
                        let gradient = drawContext.createRadialGradient(0,0,0,0,0,coreR*2.5);
                        gradient.addColorStop(0, `hsla(${activeHue}, 100%, 50%, ${0.3 * flickerValue})`);
                        gradient.addColorStop(1, 'transparent');
                        drawContext.fillStyle = gradient; drawContext.beginPath(); drawContext.arc(0,0,coreR*2.5,0,Math.PI*2); drawContext.fill();
                    }
                    for(let layer=0; layer<2; layer++) {
                        drawContext.fillStyle = layer === 0 ? `hsla(${activeHue-20}, 100%, 60%, ${0.5*flickerValue})` : `hsla(${activeHue+20}, 100%, 80%, ${0.7*flickerValue})`;
                        let scale = layer === 0 ? 1 : 0.7;
                        for(let i=0; i<5; i++) {
                            drawContext.rotate((Math.PI*2)/5); drawContext.beginPath(); drawContext.moveTo(0,0);
                            drawContext.bezierCurveTo(coreR*scale, -coreR*scale, coreR*scale*1.5, -coreR*scale*0.5, coreR*scale*1.5, 0);
                            drawContext.bezierCurveTo(coreR*scale*1.5, coreR*scale*0.5, coreR*scale, coreR*scale, 0,0); drawContext.fill();
                        }
                    }
                } else if (engineConfig.mood === 'fire') {
                    const dynamicSize = this.radius * (1 + Math.sin(animationTime * 0.05 + this.cyclePhase) * 0.3);
                    if (engineConfig.glow) {
                        let gradient = drawContext.createRadialGradient(this.posX, this.posY-dynamicSize*0.5, 0, this.posX, this.posY-dynamicSize*0.5, dynamicSize*2.5);
                        gradient.addColorStop(0, `hsla(${activeHue}, 100%, 50%, ${0.3 * flickerValue})`); gradient.addColorStop(1, 'transparent');
                        drawContext.fillStyle = gradient; drawContext.beginPath(); drawContext.arc(this.posX, this.posY-dynamicSize*0.5, dynamicSize*2.5, 0, Math.PI*2); drawContext.fill();
                    }
                    drawContext.fillStyle = `hsla(${activeHue}, 100%, 60%, ${flickerValue})`;
                    if (engineConfig.fstyle === 'poly') {
                        drawContext.beginPath();
                        for(let i=0; i<6; i++) {
                            let angle = (i / 6) * Math.PI * 2 + this.rotation;
                            let dist = dynamicSize * (1 + Math.sin(animationTime * 0.05 + i) * 0.5);
                            drawContext.lineTo(this.posX + Math.cos(angle) * dist, this.posY + Math.sin(angle) * dist - (dynamicSize*0.5));
                        }
                        drawContext.closePath(); drawContext.fill();
                    } else {
                        drawContext.beginPath(); drawContext.moveTo(this.posX, this.posY);
                        const h = dynamicSize * 1.8; const w = dynamicSize * 0.8;
                        const drift = Math.sin(animationTime * 0.1 + this.cyclePhase) * (dynamicSize * 0.3);
                        drawContext.bezierCurveTo(this.posX - w, this.posY, this.posX - w + drift, this.posY - h, this.posX, this.posY - h * 1.2);
                        drawContext.bezierCurveTo(this.posX + w + drift, this.posY - h, this.posX + w, this.posY, this.posX, this.posY);
                        drawContext.fill();
                    }
                } else if (engineConfig.mood === 'hearts') {
                    const s = this.radius * 0.6;
                    if (engineConfig.glow) {
                        let gradient = drawContext.createRadialGradient(this.posX, this.posY+s*0.5, 0, this.posX, this.posY+s*0.5, s*3);
                        gradient.addColorStop(0, `hsla(${activeHue}, 100%, 50%, ${0.3 * flickerValue})`);
                        gradient.addColorStop(1, 'transparent');
                        drawContext.fillStyle = gradient; drawContext.beginPath(); drawContext.arc(this.posX, this.posY+s*0.5, s*3, 0, Math.PI*2); drawContext.fill();
                    }
                    drawContext.fillStyle = `hsla(${activeHue}, 100%, 50%, ${flickerValue})`;
                    drawContext.beginPath(); drawContext.moveTo(this.posX, this.posY);
                    drawContext.bezierCurveTo(this.posX-s, this.posY-s, this.posX-s*1.5, this.posY+s/2, this.posX, this.posY+s*1.3);
                    drawContext.bezierCurveTo(this.posX+s*1.5, this.posY+s/2, this.posX+s, this.posY-s, this.posX, this.posY); drawContext.fill();
                } else if (engineConfig.mood === 'bubbles') {
                    if (engineConfig.glow) {
                        let gradient = drawContext.createRadialGradient(this.posX, this.posY, 0, this.posX, this.posY, this.radius*1.5);
                        gradient.addColorStop(0, `hsla(${activeHue}, 100%, 50%, ${0.4 * flickerValue})`);
                        gradient.addColorStop(1, 'transparent');
                        drawContext.fillStyle = gradient; drawContext.beginPath(); drawContext.arc(this.posX, this.posY, this.radius*1.5, 0, Math.PI*2); drawContext.fill();
                    }
                    drawContext.fillStyle = `hsla(${activeHue}, 100%, 50%, ${flickerValue})`; drawContext.beginPath(); drawContext.arc(this.posX, this.posY, this.radius/2, 0, Math.PI*2); drawContext.fill();
                } else if (engineConfig.mood === 'rain') {
                    drawContext.strokeStyle = `hsla(${activeHue}, 100%, 75%, ${0.6 * flickerValue})`; drawContext.lineWidth = 2;
                    drawContext.beginPath(); drawContext.moveTo(this.posX, this.posY); drawContext.lineTo(this.posX, this.posY + this.radius); drawContext.stroke();
                }
                drawContext.restore();
            }
        }

        function generateElementPool() { elementArray = []; for (let i = 0; i < engineConfig.count; i++) elementArray.push(new VisualElement(true)); }
        
        function updateVisualMood(selectedMood) {
            engineConfig.mood = selectedMood; 
            const moodColorTable = { hearts: 345, fire: 22, bubbles: 200, rain: 210, bloom: 300 };
            if (!queryParams.has('h')) engineConfig.hue = moodColorTable[selectedMood];
            document.body.classList.toggle('mouse-enabled', ['hearts', 'bubbles', 'bloom'].includes(selectedMood));
            document.body.classList.toggle('fire-enabled', selectedMood === 'fire');
            refreshUiColor(); generateElementPool(); synchronizeUrlParameters();
            document.querySelectorAll('.mode-selector button').forEach(btn => btn.classList.toggle('active', btn.id === 'btn-'+selectedMood));
        }

        function refreshUiColor() { 
            document.documentElement.style.setProperty('--ui-accent', `hsl(${engineConfig.hue}, 100%, 50%)`); 
            document.getElementById('val-hue').innerText = Math.floor(engineConfig.hue) + "Â°"; 
            document.getElementById('input-hue').value = engineConfig.hue;
        }

        function syncUiToState() {
            ['count', 'speed', 'size', 'hue', 'mradius', 'flickerStr', 'flickerSpeed'].forEach(id => { 
                document.getElementById('input-'+id).value = engineConfig[id]; 
                document.getElementById('val-'+id).innerText = (id === 'speed' || id === 'flickerStr' || id === 'flickerSpeed') ? engineConfig[id].toFixed(2) : Math.floor(engineConfig[id]); 
            });
            document.getElementById('input-glow').checked = engineConfig.glow; 
            document.getElementById('input-physics').checked = engineConfig.physics;
            document.getElementById('input-autohue').checked = engineConfig.autohue;
            document.getElementById('input-mousehit').checked = engineConfig.mousehit;
            document.getElementById('input-fstyle').value = engineConfig.fstyle;
            uiPanel.classList.toggle('visible', engineConfig.uiVisible); uiHint.classList.toggle('visible', engineConfig.uiVisible);
        }

        ['count', 'speed', 'size', 'hue', 'mradius', 'flickerStr', 'flickerSpeed'].forEach(id => {
            document.getElementById('input-'+id).addEventListener('input', (e) => {
                engineConfig[id] = parseFloat(e.target.value); syncUiToState(); synchronizeUrlParameters();
                if (id === 'hue') { engineConfig.autohue = false; document.getElementById('input-autohue').checked = false; refreshUiColor(); }
                if (id === 'count' || id === 'size') generateElementPool();
            });
        });

        document.getElementById('input-glow').addEventListener('change', (e) => { engineConfig.glow = e.target.checked; synchronizeUrlParameters(); });
        document.getElementById('input-physics').addEventListener('change', (e) => { engineConfig.physics = e.target.checked; synchronizeUrlParameters(); });
        document.getElementById('input-autohue').addEventListener('change', (e) => { engineConfig.autohue = e.target.checked; synchronizeUrlParameters(); });
        document.getElementById('input-mousehit').addEventListener('change', (e) => { engineConfig.mousehit = e.target.checked; synchronizeUrlParameters(); });
        document.getElementById('input-fstyle').addEventListener('change', (e) => { engineConfig.fstyle = e.target.value; synchronizeUrlParameters(); });
        document.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'm') { engineConfig.uiVisible = !engineConfig.uiVisible; syncUiToState(); synchronizeUrlParameters(); } });

        function startAnimationLoop() {
            animationTime++;
            if (engineConfig.autohue) { engineConfig.hue = (engineConfig.hue + 0.5) % 360; refreshUiColor(); }
            drawContext.globalCompositeOperation = 'source-over'; drawContext.fillStyle = "black";
            drawContext.globalAlpha = (engineConfig.mood === 'fire' || engineConfig.mood === 'bloom') ? 0.15 : 0.25; 
            drawContext.fillRect(0,0,viewWidth,viewHeight);
            if (engineConfig.mood === 'fire') {
                let backdrop = drawContext.createLinearGradient(0, viewHeight, 0, viewHeight - 400);
                backdrop.addColorStop(0, `hsla(${engineConfig.hue}, 100%, 15%, 0.4)`); backdrop.addColorStop(1, 'transparent');
                drawContext.fillStyle = backdrop; drawContext.fillRect(0, viewHeight-400, viewWidth, 400);
            }
            elementArray.forEach(el => { el.updatePhysics(); el.renderToCanvas(); });
            requestAnimationFrame(startAnimationLoop);
        }

        function handleWindowResize() { viewWidth = renderCanvas.width = window.innerWidth; viewHeight = renderCanvas.height = window.innerHeight; generateElementPool(); }
        window.addEventListener('resize', handleWindowResize); handleWindowResize(); syncUiToState(); updateVisualMood(engineConfig.mood); startAnimationLoop();
    </script>
</body>
</html>