<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comfy Engine | Wallpaper / Scene tool</title>
    <style>
        :root { --bg: #000; --ui-accent: #bc13fe; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI Containers */
        #ui-container, #main-hint, #help-modal { opacity: 0; pointer-events: none; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
        #ui-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(20px);
            z-index: 10; background: rgba(10, 10, 10, 0.9); backdrop-filter: blur(30px);
            padding: 25px; border-radius: 25px; border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; gap: 12px; min-width: 360px;
            max-height: 85vh; overflow-y: auto; scrollbar-width: thin;
        }
        #ui-container.visible, #main-hint.visible { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: all; }
        #main-hint.visible { opacity: 0.4; }
        #main-hint { position: absolute; top: 20px; left: 50%; transform: translateX(-50%) translateY(-20px); font-size: 11px; letter-spacing: 2px; text-transform: uppercase; z-index: 5; }

        /* Menu Elements */
        .mode-selector { display: flex; justify-content: center; gap: 8px; margin-bottom: 5px; flex-wrap: wrap; }
        button { background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); border: 1px solid rgba(255,255,255,0.1); padding: 8px 12px; border-radius: 12px; cursor: pointer; font-size: 10px; font-weight: 700; text-transform: uppercase; transition: 0.3s; }
        button:hover { background: rgba(255,255,255,0.1); color: white; }
        button.active { background: var(--ui-accent); color: white; border-color: var(--ui-accent); box-shadow: 0 0 15px var(--ui-accent); }
        
        .control-row { display: flex; flex-direction: column; gap: 4px; }
        .control-row label { font-size: 9px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; }
        
        select { 
            background: #111; color: #fff; border: 1px solid rgba(255,255,255,0.2); 
            border-radius: 8px; font-size: 10px; padding: 6px; outline: none; cursor: pointer;
            text-transform: uppercase; font-weight: bold;
        }

        input[type=range] { appearance: none; width: 100%; height: 3px; background: rgba(255,255,255,0.1); outline: none; }
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: #fff; border-radius: 50%; cursor: pointer; }
        .hue-slider { background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%) !important; }
        
        .switch-container { display: flex; align-items: center; justify-content: space-between; margin-top: 5px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        .switch { position: relative; display: inline-block; width: 30px; height: 16px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 10px; width: 10px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--ui-accent); }
        
        /* Share & Help Section */
        .share-box { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; gap: 8px; }
        #share-url { background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.1); padding: 8px; border-radius: 8px; color: #888; font-size: 9px; width: 100%; box-sizing: border-box; }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .btn-obs { background: #333; color: white; border: none; }
        .btn-help { background: transparent; border: 1px solid rgba(255,255,255,0.2); }

        /* Modal */
        #help-modal { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -40%); 
            background: rgba(15,15,15,0.95); backdrop-filter: blur(40px);
            padding: 40px; border-radius: 30px; border: 1px solid var(--ui-accent);
            z-index: 100; max-width: 500px; text-align: center;
        }
        #help-modal.visible { opacity: 1; transform: translate(-50%, -50%); pointer-events: all; }
        #help-modal h2 { margin-top: 0; color: var(--ui-accent); text-transform: uppercase; letter-spacing: 2px; }
        #help-modal p { font-size: 13px; line-height: 1.6; color: #ccc; text-align: left; }
        
        .mouse-setting { display: none; }
        .mouse-enabled .mouse-setting { display: flex; }
    </style>
</head>
<body class="mouse-enabled">

    <div id="main-hint">M = Toggle Menu | Link saves settings</div>
    <canvas id="canvas"></canvas>

    <div id="ui-container">
        <div class="mode-selector">
            <button onclick="updateVisualMood('hearts')" id="btn-hearts">Hearts</button>
            <button onclick="updateVisualMood('bubbles')" id="btn-bubbles">Bubbles</button>
            <button onclick="updateVisualMood('bloom')" id="btn-bloom">Spirit Bloom</button>
            <button onclick="updateVisualMood('fire')" id="btn-fire">Fire</button>
            <button onclick="updateVisualMood('rain')" id="btn-rain">Rain</button>
        </div>
        
        <div class="control-row"><label>Intensity: <span id="val-count"></span></label><input type="range" id="input-count" min="1" max="500"></div>
        <div class="control-row"><label>Speed: <span id="val-speed"></span></label><input type="range" id="input-speed" min="0.1" max="15" step="0.1"></div>
        <div class="control-row"><label>Size: <span id="val-size"></span></label><input type="range" id="input-size" min="1" max="250"></div>
        <div class="control-row"><label>Hue: <span id="val-hue"></span></label><input type="range" id="input-hue" class="hue-slider" min="0" max="360" step="1"></div>
        
        <div class="control-row"><label>Flicker Power: <span id="val-flickerStr"></span></label><input type="range" id="input-flickerStr" min="0" max="1" step="0.05"></div>
        <div class="control-row"><label>Flicker Time: <span id="val-flickerSpeed"></span></label><input type="range" id="input-flickerSpeed" min="0.01" max="0.5" step="0.01"></div>
        
        <div class="control-row"><label>Hitbox Scale: <span id="val-hitbox"></span></label><input type="range" id="input-hitbox" min="0.1" max="4.0" step="0.1"></div>

        <div class="control-row mouse-setting">
            <label>Interact Mode</label>
            <select id="input-mmode">
                <option value="avoid">Avoid Mouse</option>
                <option value="follow">Follow Mouse</option>
                <option value="off">Off</option>
            </select>
        </div>

        <div class="control-row mouse-setting"><label>Interact Radius: <span id="val-mradius"></span></label><input type="range" id="input-mradius" min="10" max="1000" step="10"></div>
        <div class="control-row mouse-setting"><label>Interact Strength: <span id="val-mstrength"></span></label><input type="range" id="input-mstrength" min="0.1" max="15" step="0.1"></div>

        <div class="switch-container">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8;">Auto Hue</label>
            <label class="switch"><input type="checkbox" id="input-autohue"><span class="slider"></span></label>
        </div>

        <div class="switch-container">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8;">Flicker Glow</label>
            <label class="switch"><input type="checkbox" id="input-glow"><span class="slider"></span></label>
        </div>
        <div class="switch-container" style="border-top: none; margin-top: 0; padding-top: 0;">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8;">Smooth Physics</label>
            <label class="switch"><input type="checkbox" id="input-physics"><span class="slider"></span></label>
        </div>

        <div class="share-box">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.6;">Current Config URL</label>
            <input type="text" id="share-url" readonly onclick="this.select()">
            <div class="btn-group">
                <button class="btn-obs" onclick="copyForOBS()">Copy URL</button>
                <button class="btn-help" onclick="toggleHelp(true)">Guide / Help</button>
            </div>
        </div>
    </div>

    <div id="help-modal">
        <h2>Setup Guide</h2>
        <p>
            <strong>OBS Browser Source:</strong> Click 'Copy URL' and paste it as a Browser Source. The UI will stay hidden automatically.<br><br>
            <strong>Lively / Wallpaper Engine:</strong> Use the URL in your wallpaper software. Adjust 'Interact Mode' to react to your mouse movements on your desktop.<br><br>
            <strong>Website Background:</strong> This is a lightweight HTML5 engine. You can use it as a background for any site.<br><br>
            <strong>Shortcut:</strong> Press [M] to toggle the menu.
        </p>
        <button onclick="toggleHelp(false)" style="margin-top: 20px; width: 100%;">Close Guide</button>
    </div>

    <script>
        const renderCanvas = document.getElementById('canvas');
        const drawContext = renderCanvas.getContext('2d');
        const uiPanel = document.getElementById('ui-container');
        const uiHint = document.getElementById('main-hint');
        let viewWidth, viewHeight, elementArray = [], animationTime = 0;
        let mousePosition = { x: -2000, y: -2000 };

        const queryParams = new URLSearchParams(window.location.search);
        
        // UPDATED DEFAULTS TO MATCH YOUR REQUEST
        let engineConfig = {
            mood: queryParams.get('m') || 'hearts',
            count: parseInt(queryParams.get('c')) || 491,
            speed: parseFloat(queryParams.get('s')) || 1.3,
            size: parseInt(queryParams.get('z')) || 250,
            hue: parseInt(queryParams.get('h')) || 335,
            autohue: queryParams.get('ah') === '1',
            glow: queryParams.get('g') !== '0',
            physics: queryParams.get('p') !== '0',
            uiVisible: queryParams.get('u') !== '0',
            mmode: queryParams.get('mm') || 'off',
            mradius: parseInt(queryParams.get('mr')) || 250,
            mstrength: parseFloat(queryParams.get('mst')) || 1.8,
            flickerStr: parseFloat(queryParams.get('fs')) || 0.3,
            flickerSpeed: parseFloat(queryParams.get('fsp')) || 0.1,
            hitbox: parseFloat(queryParams.get('hb')) || 1.1
        };

        window.addEventListener('mousemove', (e) => { mousePosition.x = e.clientX; mousePosition.y = e.clientY; });

        function synchronizeUrlParameters() {
            const params = new URLSearchParams();
            const shortKeys = {mood:'m', count:'c', speed:'s', size:'z', hue:'h', autohue:'ah', glow:'g', physics:'p', uiVisible:'u', mmode:'mm', mradius:'mr', mstrength:'mst', flickerStr:'fs', flickerSpeed:'fsp', hitbox:'hb'};
            Object.keys(engineConfig).forEach(key => {
                let val = engineConfig[key];
                if (typeof val === 'boolean') val = val ? '1' : '0';
                params.set(shortKeys[key] || key, val);
            });
            const fullUrl = window.location.origin + window.location.pathname + '?' + params.toString();
            window.history.replaceState(null, '', fullUrl);
            document.getElementById('share-url').value = fullUrl;
            return params;
        }

        function copyForOBS() {
            const params = synchronizeUrlParameters();
            params.set('u', '0'); // Force UI off for the copied link
            const obsUrl = window.location.origin + window.location.pathname + '?' + params.toString();
            navigator.clipboard.writeText(obsUrl);
            const btn = document.querySelector('.btn-obs');
            btn.innerText = "Copied!";
            setTimeout(() => btn.innerText = "Copy URL", 2000);
        }

        function toggleHelp(show) { document.getElementById('help-modal').classList.toggle('visible', show); }

        class VisualElement {
            constructor(isInitialBatch = false) { this.resetState(isInitialBatch); }
            resetState(randomPlacement = false) {
                this.posX = Math.random() * viewWidth;
                this.posY = randomPlacement ? Math.random() * viewHeight : (engineConfig.mood === 'rain' ? -100 : viewHeight + 250);
                this.radius = Math.random() * engineConfig.size * 0.4 + 10;
                this.cyclePhase = Math.random() * Math.PI * 2;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationVelocity = (Math.random() - 0.5) * 0.05;
                this.hueVariation = (Math.random() - 0.5) * 40;
                this.driftFactor = 0.5 + Math.random(); 
                this.baseVelX = (Math.random() - 0.5) * 0.5 * this.driftFactor;
                this.baseVelY = engineConfig.mood === 'rain' ? (Math.random() * 5 + 5) : -(Math.random() * 0.5 + 0.3) * this.driftFactor;
                this.currentVelX = this.baseVelX; this.currentVelY = this.baseVelY;
            }
            updatePhysics() {
                if (engineConfig.physics && ['hearts', 'bubbles', 'fire', 'bloom'].includes(engineConfig.mood)) {
                    for (let other of elementArray) {
                        if (this === other) continue;
                        let dx = other.posX - this.posX, dy = other.posY - this.posY;
                        let minDist = (this.radius + other.radius) * 0.45 * engineConfig.hitbox;
                        if (Math.abs(dx) < minDist && Math.abs(dy) < minDist) {
                            let distSq = dx*dx + dy*dy;
                            if (distSq < minDist * minDist && distSq > 0) {
                                let angle = Math.atan2(dy, dx);
                                let pushX = Math.cos(angle) * 0.05;
                                let pushY = Math.sin(angle) * 0.05;
                                this.currentVelX -= pushX; this.currentVelY -= pushY;
                                other.currentVelX += pushX; other.currentVelY += pushY;
                            }
                        }
                    }
                }

                if (engineConfig.mmode !== 'off' && ['hearts', 'bubbles', 'bloom'].includes(engineConfig.mood)) {
                    let dxM = mousePosition.x - this.posX, dyM = mousePosition.y - this.posY;
                    let distM = Math.sqrt(dxM*dxM + dyM*dyM);
                    if (distM < engineConfig.mradius) {
                        let force = (engineConfig.mradius - distM) / engineConfig.mradius;
                        let angle = Math.atan2(dyM, dxM);
                        let moveX = (engineConfig.mmode === 'avoid' ? -Math.cos(angle) : Math.cos(angle)) * force * engineConfig.mstrength;
                        let moveY = (engineConfig.mmode === 'avoid' ? -Math.sin(angle) : Math.sin(angle)) * force * engineConfig.mstrength;
                        this.currentVelX += moveX * 0.1; this.currentVelY += moveY * 0.1;
                    }
                }

                this.currentVelX += (this.baseVelX - this.currentVelX) * 0.03;
                this.currentVelY += (this.baseVelY - this.currentVelY) * 0.03;
                this.posX += this.currentVelX * engineConfig.speed;
                this.posY += this.currentVelY * engineConfig.speed;
                this.rotation += this.rotationVelocity * (engineConfig.speed * 0.5);
                if (this.posY < -500 || this.posY > viewHeight + 500 || this.posX < -500 || this.posX > viewWidth + 500) this.resetState();
            }

            renderToCanvas() {
                const drawLimit = this.radius * 2.5;
                if (this.posX < -drawLimit || this.posX > viewWidth + drawLimit || this.posY < -drawLimit || this.posY > viewHeight + drawLimit) return;
                drawContext.save();
                const flickerValue = engineConfig.glow ? ( (1-engineConfig.flickerStr) + Math.sin(animationTime * engineConfig.flickerSpeed + this.cyclePhase) * engineConfig.flickerStr) : 1;
                const activeHue = engineConfig.hue + this.hueVariation;
                if (engineConfig.glow) drawContext.globalCompositeOperation = 'lighter';
                
                if (engineConfig.mood === 'bloom') {
                    drawContext.translate(this.posX, this.posY); drawContext.rotate(this.rotation + animationTime * 0.005);
                    const coreR = this.radius * 0.8;
                    for(let layer=0; layer<2; layer++) {
                        drawContext.fillStyle = layer === 0 ? `hsla(${activeHue}, 100%, 60%, ${0.4*flickerValue})` : `hsla(${activeHue+20}, 100%, 80%, ${0.6*flickerValue})`;
                        let scale = layer === 0 ? 1 : 0.7;
                        for(let i=0; i<5; i++) {
                            drawContext.rotate((Math.PI*2)/5); drawContext.beginPath(); drawContext.moveTo(0,0);
                            drawContext.bezierCurveTo(coreR*scale, -coreR*scale, coreR*scale*1.5, -coreR*scale*0.5, coreR*scale*1.5, 0);
                            drawContext.bezierCurveTo(coreR*scale*1.5, coreR*scale*0.5, coreR*scale, coreR*scale, 0,0); drawContext.fill();
                        }
                    }
                } else if (engineConfig.mood === 'fire') {
                    const dynamicSize = this.radius * (1 + Math.sin(animationTime * 0.05 + this.cyclePhase) * 0.3);
                    drawContext.fillStyle = `hsla(${activeHue}, 100%, 60%, ${flickerValue})`;
                    drawContext.beginPath();
                    for(let i=0; i<6; i++) {
                        let angle = (i / 6) * Math.PI * 2 + this.rotation;
                        let dist = dynamicSize * (1 + Math.sin(animationTime * 0.05 + i) * 0.5);
                        drawContext.lineTo(this.posX + Math.cos(angle) * dist, this.posY + Math.sin(angle) * dist - (dynamicSize*0.5));
                    }
                    drawContext.closePath(); drawContext.fill();
                } else if (engineConfig.mood === 'hearts') {
                    const s = this.radius * 0.6;
                    drawContext.fillStyle = `hsla(${activeHue}, 100%, 50%, ${flickerValue})`;
                    drawContext.beginPath(); drawContext.moveTo(this.posX, this.posY);
                    drawContext.bezierCurveTo(this.posX-s, this.posY-s, this.posX-s*1.5, this.posY+s/2, this.posX, this.posY+s*1.3);
                    drawContext.bezierCurveTo(this.posX+s*1.5, this.posY+s/2, this.posX+s, this.posY-s, this.posX, this.posY); drawContext.fill();
                } else if (engineConfig.mood === 'bubbles') {
                    drawContext.fillStyle = `hsla(${activeHue}, 100%, 50%, ${flickerValue})`; drawContext.beginPath(); drawContext.arc(this.posX, this.posY, this.radius/2, 0, Math.PI*2); drawContext.fill();
                } else if (engineConfig.mood === 'rain') {
                    drawContext.strokeStyle = `hsla(${activeHue}, 100%, 75%, ${0.6 * flickerValue})`; drawContext.lineWidth = 2;
                    drawContext.beginPath(); drawContext.moveTo(this.posX, this.posY); drawContext.lineTo(this.posX, this.posY + this.radius); drawContext.stroke();
                }
                drawContext.restore();
            }
        }

        function generateElementPool() { elementArray = []; for (let i = 0; i < engineConfig.count; i++) elementArray.push(new VisualElement(true)); }
        
        function updateVisualMood(selectedMood) {
            engineConfig.mood = selectedMood; 
            document.body.classList.toggle('mouse-enabled', ['hearts', 'bubbles', 'bloom'].includes(selectedMood));
            refreshUiColor(); generateElementPool(); synchronizeUrlParameters();
            document.querySelectorAll('.mode-selector button').forEach(btn => btn.classList.toggle('active', btn.id === 'btn-'+selectedMood));
        }

        function refreshUiColor() { 
            document.documentElement.style.setProperty('--ui-accent', `hsl(${engineConfig.hue}, 100%, 50%)`); 
            document.getElementById('val-hue').innerText = Math.floor(engineConfig.hue) + "Â°"; 
            document.getElementById('input-hue').value = engineConfig.hue;
        }

        function syncUiToState() {
            ['count', 'speed', 'size', 'hue', 'mradius', 'mstrength', 'flickerStr', 'flickerSpeed', 'hitbox'].forEach(id => { 
                document.getElementById('input-'+id).value = engineConfig[id]; 
                document.getElementById('val-'+id).innerText = (['speed', 'mstrength', 'flickerStr', 'flickerSpeed', 'hitbox'].includes(id)) ? parseFloat(engineConfig[id]).toFixed(1) : Math.floor(engineConfig[id]); 
            });
            document.getElementById('input-glow').checked = engineConfig.glow; 
            document.getElementById('input-physics').checked = engineConfig.physics;
            document.getElementById('input-autohue').checked = engineConfig.autohue;
            document.getElementById('input-mmode').value = engineConfig.mmode;
            uiPanel.classList.toggle('visible', engineConfig.uiVisible); uiHint.classList.toggle('visible', engineConfig.uiVisible);
            synchronizeUrlParameters();
        }

        ['count', 'speed', 'size', 'hue', 'mradius', 'mstrength', 'flickerStr', 'flickerSpeed', 'hitbox'].forEach(id => {
            document.getElementById('input-'+id).addEventListener('input', (e) => {
                engineConfig[id] = parseFloat(e.target.value); syncUiToState();
                if (id === 'hue') { engineConfig.autohue = false; document.getElementById('input-autohue').checked = false; refreshUiColor(); }
                if (id === 'count' || id === 'size') generateElementPool();
            });
        });

        document.getElementById('input-glow').addEventListener('change', (e) => { engineConfig.glow = e.target.checked; synchronizeUrlParameters(); });
        document.getElementById('input-physics').addEventListener('change', (e) => { engineConfig.physics = e.target.checked; synchronizeUrlParameters(); });
        document.getElementById('input-autohue').addEventListener('change', (e) => { engineConfig.autohue = e.target.checked; synchronizeUrlParameters(); });
        document.getElementById('input-mmode').addEventListener('change', (e) => { engineConfig.mmode = e.target.value; synchronizeUrlParameters(); });
        document.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'm') { engineConfig.uiVisible = !engineConfig.uiVisible; syncUiToState(); } });

        function startAnimationLoop() {
            animationTime++;
            if (engineConfig.autohue) { engineConfig.hue = (engineConfig.hue + 0.5) % 360; refreshUiColor(); }
            drawContext.globalCompositeOperation = 'source-over'; drawContext.fillStyle = "black";
            drawContext.globalAlpha = (engineConfig.mood === 'fire' || engineConfig.mood === 'bloom') ? 0.15 : 0.25; 
            drawContext.fillRect(0,0,viewWidth,viewHeight);
            elementArray.forEach(el => { el.updatePhysics(); el.renderToCanvas(); });
            requestAnimationFrame(startAnimationLoop);
        }

        function handleWindowResize() { viewWidth = renderCanvas.width = window.innerWidth; viewHeight = renderCanvas.height = window.innerHeight; generateElementPool(); }
        window.addEventListener('resize', handleWindowResize); handleWindowResize(); syncUiToState(); updateVisualMood(engineConfig.mood); startAnimationLoop();
    </script>
</body>
</html>