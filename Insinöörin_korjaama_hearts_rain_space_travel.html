<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comfy Engine | Wallpaper & Overlay tool</title>
    <style>
        :root { --bg: transparent; --ui-accent: #bc13fe; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: var(--bg); color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; will-change: transform; }
        
        #ui-container, #main-hint { opacity: 0; pointer-events: none; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
        
        #ui-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(20px);
            z-index: 10; background: rgba(10, 10, 10, 0.9); backdrop-filter: blur(30px);
            padding: 25px; border-radius: 25px; border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; gap: 12px; min-width: 380px;
            max-height: 85vh; overflow-y: auto; scrollbar-width: thin;
            user-select: none; -webkit-user-select: none;
        }
        
        #ui-container.visible, #main-hint.visible { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: all; }
        #main-hint.visible { opacity: 0.4; }
        #main-hint { position: absolute; top: 20px; left: 50%; transform: translateX(-50%) translateY(-20px); font-size: 11px; letter-spacing: 2px; text-transform: uppercase; z-index: 5; }

        .section-label { font-size: 10px; font-weight: 800; color: var(--ui-accent); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px; border-bottom: 1px solid rgba(188, 19, 254, 0.3); padding-bottom: 4px; }
        
        .mode-selector { display: flex; justify-content: center; gap: 8px; margin-bottom: 5px; flex-wrap: wrap; }
        button { background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.5); border: 1px solid rgba(255,255,255,0.1); padding: 8px 12px; border-radius: 12px; cursor: pointer; font-size: 10px; font-weight: 700; text-transform: uppercase; transition: 0.3s; }
        button:hover { background: rgba(255,255,255,0.1); color: white; }
        button.active { background: var(--ui-accent); color: white; border-color: var(--ui-accent); box-shadow: 0 0 15px var(--ui-accent); }
        
        .control-row { display: flex; flex-direction: column; gap: 4px; margin-bottom: 4px; }
        .control-row label { font-size: 9px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; display: flex; justify-content: space-between; }
        
        select { background: #111; color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; font-size: 10px; padding: 6px; outline: none; cursor: pointer; text-transform: uppercase; font-weight: bold; }
        
        input[type=range] { appearance: none; width: 100%; height: 3px; background: rgba(255,255,255,0.1); outline: none; touch-action: none; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: #fff; border-radius: 50%; cursor: pointer; }
        
        .hue-slider { background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%) !important; }
        
        .switch-container { display: flex; align-items: center; justify-content: space-between; padding: 4px 0; }
        .switch { position: relative; display: inline-block; width: 30px; height: 16px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 10px; width: 10px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--ui-accent); }
        
        .share-box { margin-top: 10px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; gap: 8px; }
        #share-url { background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.1); padding: 8px; border-radius: 8px; color: #888; font-size: 9px; width: 100%; box-sizing: border-box; }

        .glow-only, .can-interact, .physics-only, .space-only, .hearts-only { display: none; }
        .glow-enabled .glow-only { display: flex; }
        .mouse-enabled .can-interact { display: flex; }
        .physics-enabled .physics-only { display: block; }
        .space-active .space-only { display: flex; }
        .hearts-active .hearts-only { display: flex; }

        #label-appearance::after { content: "Appearance"; }
        .space-active #label-appearance::after { content: "Planets"; }
    </style>
</head>
<body>

    <div id="main-hint">M = Toggle Menu | Link saves settings</div>
    <canvas id="canvas"></canvas>

    <div id="ui-container">
        <div class="mode-selector">
            <button onclick="updateVisualMood('hearts')" id="btn-hearts">Hearts</button>
            <button onclick="updateVisualMood('bubbles')" id="btn-bubbles">Bubbles</button>
            <button onclick="updateVisualMood('bloom')" id="btn-bloom">Spirit Bloom</button>
            <button onclick="updateVisualMood('fire')" id="btn-fire">Fire</button>
            <button onclick="updateVisualMood('rain')" id="btn-rain">Rain</button>
            <button onclick="updateVisualMood('space')" id="btn-space">Space Travel</button>
        </div>
        
        <div class="section-label">Environment</div>
        <div class="control-row">
            <label>Background</label>
            <select id="input-bgstyle">
                <option value="transparent">Transparent (Overlay)</option>
                <option value="black">Solid Black</option>
            </select>
        </div>

        <div class="control-row hearts-only">
            <label>Heart Style</label>
            <select id="input-heartStyle">
                <option value="raising">Raising</option>
                <option value="matrix">Matrix Falling</option>
                <option value="space">Space Travel</option>
            </select>
        </div>

        <div class="control-row space-only"><label>Star Count <span><span id="val-starCount"></span></span></label><input type="range" id="input-starCount" min="0" max="2000" step="10"></div>
        <div class="control-row space-only"><label>Star Speed <span><span id="val-starSpeed"></span></span></label><input type="range" id="input-starSpeed" min="0" max="50" step="0.5"></div>
        <div class="control-row space-only"><label>Star Size <span><span id="val-starSize"></span></span></label><input type="range" id="input-starSize" min="0.1" max="10" step="0.1"></div>

        <div class="section-label" id="label-appearance"></div>
        <div class="control-row"><label>Intensity <span><span id="val-count"></span></span></label><input type="range" id="input-count" min="1" max="1000"></div>
        <div class="control-row"><label>Element Size <span><span id="val-size"></span></span></label><input type="range" id="input-size" min="1" max="1500"></div>
        <div class="control-row"><label>Movement Speed <span><span id="val-speed"></span></span></label><input type="range" id="input-speed" min="0" max="30" step="0.1"></div>
        <div class="control-row"><label>Hue <span><span id="val-hue"></span></span></label><input type="range" id="input-hue" class="hue-slider" min="0" max="360" step="1"></div>
        
        <div class="switch-container">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8;">Auto Hue (Cycle)</label>
            <label class="switch"><input type="checkbox" id="input-autohue"><span class="slider"></span></label>
        </div>

        <div class="switch-container">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8;">Enhanced Glow</label>
            <label class="switch"><input type="checkbox" id="input-glow"><span class="slider"></span></label>
        </div>
        
        <div class="control-row glow-only"><label>Glow Strength <span><span id="val-glowIntensity"></span></span></label><input type="range" id="input-glowIntensity" min="0" max="100" step="1"></div>
        <div class="control-row glow-only"><label>Glow Radius <span><span id="val-glowRadius"></span></span></label><input type="range" id="input-glowRadius" min="1" max="10" step="0.1"></div>

        <div class="section-label">Pulse</div>
        <div class="control-row"><label>Pulse Intensity <span><span id="val-flickerStr"></span></span></label><input type="range" id="input-flickerStr" min="0" max="1" step="0.05"></div>
        <div class="control-row"><label>Pulse Speed <span><span id="val-flickerSpeed"></span></span></label><input type="range" id="input-flickerSpeed" min="0.01" max="0.5" step="0.01"></div>

        <div class="physics-only">
            <div class="section-label">Physics</div>
            <div class="switch-container">
                <label style="font-size: 9px; text-transform: uppercase; opacity: 0.8;">Smooth Physics</label>
                <label class="switch"><input type="checkbox" id="input-physics"><span class="slider"></span></label>
            </div>
            <div class="control-row"><label>Collision Scale <span><span id="val-hitbox"></span></span></label><input type="range" id="input-hitbox" min="0.1" max="4.0" step="0.1"></div>
        </div>

        <div class="section-label can-interact">Interaction</div>
        <div class="control-row can-interact">
            <label>Interact Mode</label>
            <select id="input-mmode">
                <option value="off">Off</option>
                <option value="avoid">Avoid Mouse</option>
                <option value="follow">Follow Mouse</option>
            </select>
        </div>
        <div class="control-row can-interact"><label>Interact Radius <span><span id="val-mradius"></span></span></label><input type="range" id="input-mradius" min="10" max="1000" step="10"></div>
        <div class="control-row can-interact"><label>Interact Strength <span><span id="val-mstrength"></span></span></label><input type="range" id="input-mstrength" min="0.1" max="15" step="0.1"></div>

        <div class="share-box">
            <label style="font-size: 9px; text-transform: uppercase; opacity: 0.6;">Current Config URL</label>
            <input type="text" id="share-url" readonly onclick="this.select()">
            <button onclick="copyForOBS()" style="margin-top:5px; width:100%">Copy URL for OBS</button>
        </div>
    </div>

    <script>
        const renderCanvas = document.getElementById('canvas');
        const drawContext = renderCanvas.getContext('2d');
        const uiPanel = document.getElementById('ui-container');
        const uiHint = document.getElementById('main-hint');
        let viewWidth, viewHeight, elementArray = [], starArray = [], animationTime = 0;
        let mousePosition = { x: -2000, y: -2000 };

        const shortKeys = {mood:'m', count:'c', speed:'s', size:'z', hue:'h', autohue:'ah', glow:'g', glowIntensity:'gi', glowRadius:'gr', physics:'p', uiVisible:'u', mmode:'mm', mradius:'mr', mstrength:'mst', flickerStr:'fs', flickerSpeed:'fsp', hitbox:'hb', bgstyle:'bgs', starCount:'sc', starSpeed:'ss', starSize:'sz', heartStyle: 'hs'};

        let engineConfig = {
            mood: 'hearts', count: 491, speed: 0.3, size: 250, hue: 335, autohue: false, glow: true, glowIntensity: 92, glowRadius: 1.1, physics: true, uiVisible: true, mmode: 'off', mradius: 250, mstrength: 1.8, flickerStr: 0.3, flickerSpeed: 0.1, hitbox: 1.0, bgstyle: 'black', starCount: 400, starSpeed: 5, starSize: 2.0, heartStyle: 'raising'
        };

        function loadFromUrl() {
            const query = new URLSearchParams(window.location.search);
            Object.keys(shortKeys).forEach(longKey => {
                const shortKey = shortKeys[longKey];
                if (query.has(shortKey)) {
                    let val = query.get(shortKey);
                    if (val === '1' || val === '0') engineConfig[longKey] = val === '1';
                    else if (!isNaN(val) && !['mood', 'mmode', 'bgstyle', 'heartStyle'].includes(longKey)) engineConfig[longKey] = parseFloat(val);
                    else engineConfig[longKey] = val;
                }
            });
        }

        function synchronizeUrlParameters(hideUiInLink = false) {
            const params = new URLSearchParams();
            Object.keys(engineConfig).forEach(key => {
                let val = engineConfig[key];
                if (key === 'uiVisible' && hideUiInLink) val = false;
                if (typeof val === 'boolean') val = val ? '1' : '0';
                params.set(shortKeys[key] || key, val);
            });
            const finalUrl = window.location.origin + window.location.pathname + '?' + params.toString();
            if (!hideUiInLink) window.history.replaceState(null, '', finalUrl);
            document.getElementById('share-url').value = finalUrl;
            return finalUrl;
        }

        window.addEventListener('mousemove', (e) => { mousePosition.x = e.clientX; mousePosition.y = e.clientY; });

        function copyForOBS() {
            const obsUrl = synchronizeUrlParameters(true);
            navigator.clipboard.writeText(obsUrl);
            const btn = document.querySelector('.share-box button');
            btn.innerText = "Copied!";
            setTimeout(() => btn.innerText = "Copy URL for OBS", 2000);
        }

        class Star {
            constructor(isInitial = false) { this.reset(isInitial); }
            reset(randomZ = false) {
                this.x = (Math.random() - 0.5) * 2000;
                this.y = (Math.random() - 0.5) * 2000;
                this.z = randomZ ? Math.random() * 2000 : 2000;
                this.pz = this.z;
            }
            update() {
                this.pz = this.z;
                this.z -= engineConfig.starSpeed;
                if (this.z <= 1) this.reset();
            }
            draw() {
                const centerX = viewWidth / 2, centerY = viewHeight / 2;
                const x = centerX + (this.x / this.z) * 1000;
                const y = centerY + (this.y / this.z) * 1000;
                const px = centerX + (this.x / this.pz) * 1000;
                const py = centerY + (this.y / this.pz) * 1000;
                const size = (1 - this.z / 2000) * engineConfig.starSize;
                
                drawContext.strokeStyle = `rgba(255, 255, 255, ${Math.min(1, 1 - this.z / 2000)})`;
                drawContext.lineWidth = size;
                drawContext.lineCap = 'round';
                drawContext.beginPath(); drawContext.moveTo(x, y); drawContext.lineTo(px, py); drawContext.stroke();
            }
        }

        class VisualElement {
            constructor(isInitialBatch = false) { this.resetState(isInitialBatch); }
            resetState(randomPlacement = false) {
                const isSpace = (engineConfig.mood === 'space' || (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'space'));
                const isMatrix = (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'matrix');

                if (isSpace) {
                    this.posX = (Math.random() - 0.5) * viewWidth * 25;
                    this.posY = (Math.random() - 0.5) * viewHeight * 25;
                    this.posZ = randomPlacement ? Math.random() * 12000 : 12000;
                    this.oldZ = this.posZ;
                    this.hueVariation = (Math.random() - 0.5) * 120; 
                    this.intrinsicScale = 0.1 + Math.random() * 0.9; 
                } else if (isMatrix) {
                    const colWidth = 40;
                    this.posX = Math.floor(Math.random() * (viewWidth / colWidth)) * colWidth + (colWidth/2);
                    this.posY = randomPlacement ? (Math.random() * (viewHeight + 500) - 250) : -(Math.random() * 400 + 100);
                    this.hueVariation = (Math.random() - 0.5) * 20;
                } else {
                    this.posX = Math.random() * viewWidth;
                    this.posY = randomPlacement ? (Math.random() * (viewHeight + 400) - 200) : (engineConfig.mood === 'rain' ? -100 : viewHeight + 250);
                    this.hueVariation = (Math.random() - 0.5) * 40;
                }
                
                this.originX = this.posX;
                this.originY = this.posY;
                this.radius = Math.random() * engineConfig.size * 0.4 + 10;
                this.cyclePhase = Math.random() * Math.PI * 2;
                this.pulseSpeedScale = 0.8 + Math.random() * 0.4;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationVelocity = (Math.random() - 0.5) * 0.05;
                this.driftFactor = 0.5 + Math.random(); 
                
                this.baseVelX = (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'raising') ? 0 : (Math.random() - 0.5) * 0.5 * this.driftFactor;
                this.baseVelY = (engineConfig.mood === 'rain' || isMatrix) ? (Math.random() * 5 + 5) : -(Math.random() * 0.5 + 0.3) * this.driftFactor;
                this.currentVelX = 0; this.currentVelY = 0;
            }

            updatePhysics() {
                const isSpace = (engineConfig.mood === 'space' || (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'space'));
                const isMatrix = (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'matrix');

                if (isSpace) {
                    this.oldZ = this.posZ;
                    this.posZ -= engineConfig.speed * 25;
                    if (this.posZ <= 1) this.resetState(false);
                    return;
                }
                
                const interactiveMoods = ['hearts', 'bubbles', 'bloom'];
                const canInteract = interactiveMoods.includes(engineConfig.mood) && !isMatrix;

                if (canInteract && engineConfig.mmode !== 'off') {
                    let dxM = mousePosition.x - this.posX, dyM = mousePosition.y - this.posY, distM = Math.sqrt(dxM*dxM + dyM*dyM);
                    if (distM < engineConfig.mradius) {
                        let force = (engineConfig.mradius - distM) / engineConfig.mradius, angle = Math.atan2(dyM, dxM);
                        let moveX = (engineConfig.mmode === 'avoid' ? -Math.cos(angle) : Math.cos(angle)) * force * engineConfig.mstrength;
                        let moveY = (engineConfig.mmode === 'avoid' ? -Math.sin(angle) : Math.sin(angle)) * force * engineConfig.mstrength;
                        this.currentVelX += moveX * 0.2; this.currentVelY += moveY * 0.2;
                    }
                }

                if (engineConfig.physics && interactiveMoods.includes(engineConfig.mood) && !isMatrix) {
                    for (let other of elementArray) {
                        if (this === other) continue;
                        let dx = other.posX - this.posX, dy = other.posY - this.posY;
                        let distSq = dx * dx + dy * dy, minDist = (this.radius + other.radius) * 0.45 * engineConfig.hitbox;
                        if (distSq < minDist * minDist && distSq > 0) {
                            let dist = Math.sqrt(distSq), overlap = (minDist - dist) * 0.5, angle = Math.atan2(dy, dx);
                            this.posX -= Math.cos(angle) * overlap * 0.1;
                            this.posY -= Math.sin(angle) * overlap * 0.1;
                            this.currentVelX -= Math.cos(angle) * overlap * 0.05;
                        }
                    }
                }

                if (engineConfig.speed > 0) {
                    this.currentVelX += ((isMatrix ? 0 : this.baseVelX) - this.currentVelX) * 0.05;
                    this.currentVelY += (this.baseVelY - this.currentVelY) * 0.05;
                    this.posX += this.currentVelX * engineConfig.speed;
                    this.posY += this.currentVelY * engineConfig.speed;
                }

                this.rotation += this.rotationVelocity * (engineConfig.speed * 0.5 + 0.1);
                
                const resetBoundary = (isMatrix || engineConfig.mood === 'rain') ? 100 : 2000;
                if (engineConfig.speed > 0 && (this.posY > viewHeight + resetBoundary || this.posY < -2000 || this.posX < -2000 || this.posX > viewWidth + 2000)) {
                    this.resetState();
                }
            }

            drawHeart(x, y, radius, color) {
                const s = radius * 0.6;
                drawContext.fillStyle = color;
                drawContext.beginPath(); drawContext.moveTo(x, y);
                drawContext.bezierCurveTo(x-s, y-s, x-s*1.5, y+s/2, x, y+s*1.3);
                drawContext.bezierCurveTo(x+s*1.5, y+s/2, x+s, y-s, x, y); 
                drawContext.fill();
            }

            renderGlow(x, y, radius, hue, alpha) {
                if (!engineConfig.glow || engineConfig.glowIntensity === 0) return;
                const power = engineConfig.glowIntensity / 100;
                const glowSize = radius * engineConfig.glowRadius;
                const grad = drawContext.createRadialGradient(x, y, 0, x, y, glowSize);
                grad.addColorStop(0, `hsla(${hue}, 100%, 60%, ${alpha * power})`);
                grad.addColorStop(0.5, `hsla(${hue}, 100%, 50%, ${alpha * power * 0.3})`);
                grad.addColorStop(1, `hsla(${hue}, 100%, 40%, 0)`);
                drawContext.fillStyle = grad;
                drawContext.beginPath(); drawContext.arc(x, y, glowSize, 0, Math.PI * 2); drawContext.fill();
            }

            renderToCanvas() {
                const isSpace = (engineConfig.mood === 'space' || (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'space'));
                const isMatrix = (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'matrix');
                
                const currentPulseSpeed = engineConfig.flickerSpeed * this.pulseSpeedScale;
                const pulseVal = (1 - engineConfig.flickerStr) + Math.sin(animationTime * currentPulseSpeed + this.cyclePhase) * engineConfig.flickerStr;
                const activeHue = engineConfig.hue + this.hueVariation;
                
                drawContext.save();
                
                // FIXED: Rain mode now explicitly skips the renderGlow call
                if (engineConfig.mood !== 'rain') {
                    if (isSpace) {
                        const centerX = viewWidth/2, centerY = viewHeight/2, perspective = 1000;
                        const x = centerX + (this.posX/this.posZ)*perspective;
                        const y = centerY + (this.posY/this.posZ)*perspective;
                        const depthFactor = Math.pow(Math.max(0, 1 - this.posZ/12000), 2); 
                        const size = depthFactor * (engineConfig.size/8) * this.intrinsicScale;
                        this.renderGlow(x, y, (engineConfig.mood === 'hearts' ? size : Math.max(0.5, size)), activeHue, pulseVal);
                    } else {
                        this.renderGlow(this.posX, this.posY, this.radius, activeHue, pulseVal);
                    }
                }

                if (isSpace) {
                    const centerX = viewWidth/2, centerY = viewHeight/2, perspective = 1000;
                    const x = centerX + (this.posX/this.posZ)*perspective;
                    const y = centerY + (this.posY/this.posZ)*perspective;
                    const depthFactor = Math.pow(Math.max(0, 1 - this.posZ/12000), 2); 
                    const size = depthFactor * (engineConfig.size/8) * this.intrinsicScale;
                    
                    if (engineConfig.mood === 'hearts') {
                        this.drawHeart(x, y, size, `hsla(${activeHue}, 100%, 70%, ${pulseVal})`);
                    } else {
                        drawContext.fillStyle = `hsla(${activeHue}, 100%, 70%, ${pulseVal})`;
                        drawContext.beginPath(); drawContext.arc(x, y, Math.max(0.2, size/2), 0, Math.PI*2); drawContext.fill();
                    }
                } else if (engineConfig.mood === 'bloom') {
                    drawContext.translate(this.posX, this.posY); drawContext.rotate(this.rotation + animationTime * 0.005);
                    const coreR = this.radius * 0.8;
                    drawContext.fillStyle = `hsla(${activeHue}, 100%, 60%, ${0.6 * pulseVal})`;
                    for(let i=0; i<5; i++) {
                        drawContext.rotate((Math.PI*2)/5); drawContext.beginPath(); drawContext.moveTo(0,0);
                        drawContext.bezierCurveTo(coreR, -coreR, coreR*1.5, -coreR*0.5, coreR*1.5, 0);
                        drawContext.bezierCurveTo(coreR*1.5, coreR*0.5, coreR, coreR, 0,0); drawContext.fill();
                    }
                } else if (engineConfig.mood === 'fire') {
                    const dynamicSize = this.radius * (1 + Math.sin(animationTime * 0.05 + this.cyclePhase) * 0.3);
                    drawContext.fillStyle = `hsla(${activeHue}, 100%, 60%, ${pulseVal})`;
                    drawContext.beginPath();
                    for(let i=0; i<6; i++) {
                        let angle = (i/6)*Math.PI*2 + this.rotation;
                        let dist = dynamicSize * (1 + Math.sin(animationTime*0.05+i)*0.5);
                        drawContext.lineTo(this.posX + Math.cos(angle)*dist, this.posY + Math.sin(angle)*dist - (dynamicSize*0.5));
                    }
                    drawContext.closePath(); drawContext.fill();
                } else if (engineConfig.mood === 'hearts') {
                    this.drawHeart(this.posX, this.posY, this.radius, `hsla(${activeHue}, 100%, 50%, ${pulseVal})`);
                } else if (engineConfig.mood === 'bubbles') {
                    drawContext.fillStyle = `hsla(${activeHue}, 100%, 50%, ${pulseVal})`; 
                    drawContext.beginPath(); drawContext.arc(this.posX, this.posY, this.radius/2, 0, Math.PI*2); drawContext.fill();
                } else if (engineConfig.mood === 'rain') {
                    drawContext.strokeStyle = `hsla(${activeHue}, 100%, 75%, ${0.6 * pulseVal})`; drawContext.lineWidth = 2;
                    drawContext.beginPath(); drawContext.moveTo(this.posX, this.posY); drawContext.lineTo(this.posX, this.posY + this.radius); drawContext.stroke();
                }
                drawContext.restore();
            }
        }

        function generateElementPool() { 
            elementArray = []; for (let i = 0; i < engineConfig.count; i++) elementArray.push(new VisualElement(true)); 
            starArray = []; for (let i = 0; i < engineConfig.starCount; i++) starArray.push(new Star(true));
        }
        
        function updateVisualMood(selectedMood) {
            engineConfig.mood = selectedMood; 
            const isPhysicsMode = ['hearts', 'bubbles', 'bloom'].includes(selectedMood) && engineConfig.heartStyle !== 'matrix' && engineConfig.heartStyle !== 'space';
            document.body.classList.toggle('mouse-enabled', isPhysicsMode);
            document.body.classList.toggle('physics-enabled', isPhysicsMode);
            document.body.classList.toggle('space-active', selectedMood === 'space');
            document.body.classList.toggle('hearts-active', selectedMood === 'hearts');
            refreshUiColor(); generateElementPool(); synchronizeUrlParameters();
            document.querySelectorAll('.mode-selector button').forEach(btn => btn.classList.toggle('active', btn.id === 'btn-'+selectedMood));
        }

        function refreshUiColor() { 
            document.documentElement.style.setProperty('--ui-accent', `hsl(${engineConfig.hue}, 100%, 50%)`); 
            document.body.style.background = (engineConfig.bgstyle === 'transparent') ? 'transparent' : '#000';
            document.getElementById('val-hue').innerText = Math.floor(engineConfig.hue) + "Â°"; 
            document.getElementById('input-hue').value = engineConfig.hue;
        }

        function syncUiToState() {
            ['count', 'speed', 'size', 'hue', 'mradius', 'mstrength', 'flickerStr', 'flickerSpeed', 'hitbox', 'glowIntensity', 'glowRadius', 'starCount', 'starSpeed', 'starSize'].forEach(id => { 
                const el = document.getElementById('input-'+id);
                if(el) el.value = engineConfig[id]; 
                const valEl = document.getElementById('val-'+id);
                if(valEl) valEl.innerText = (['speed', 'mstrength', 'flickerStr', 'flickerSpeed', 'hitbox', 'glowRadius', 'starSpeed', 'starSize'].includes(id)) ? parseFloat(engineConfig[id]).toFixed(1) : Math.floor(engineConfig[id]); 
            });
            document.getElementById('input-glow').checked = engineConfig.glow; 
            document.getElementById('input-physics').checked = engineConfig.physics;
            document.getElementById('input-autohue').checked = engineConfig.autohue;
            document.getElementById('input-mmode').value = engineConfig.mmode;
            document.getElementById('input-bgstyle').value = engineConfig.bgstyle;
            document.getElementById('input-heartStyle').value = engineConfig.heartStyle;
            uiPanel.classList.toggle('visible', engineConfig.uiVisible); uiHint.classList.toggle('visible', engineConfig.uiVisible);
            document.body.classList.toggle('glow-enabled', engineConfig.glow);
            refreshUiColor(); synchronizeUrlParameters();
        }

        ['count', 'speed', 'size', 'hue', 'mradius', 'mstrength', 'flickerStr', 'flickerSpeed', 'hitbox', 'glowIntensity', 'glowRadius', 'starCount', 'starSpeed', 'starSize'].forEach(id => {
            document.getElementById('input-'+id).addEventListener('input', (e) => {
                engineConfig[id] = parseFloat(e.target.value);
                if (id === 'hue') { engineConfig.autohue = false; document.getElementById('input-autohue').checked = false; }
                if (id === 'count' || id === 'size' || id === 'starCount') generateElementPool();
                syncUiToState();
            });
        });

        document.getElementById('input-glow').addEventListener('change', (e) => { engineConfig.glow = e.target.checked; syncUiToState(); });
        document.getElementById('input-physics').addEventListener('change', (e) => { engineConfig.physics = e.target.checked; syncUiToState(); });
        document.getElementById('input-autohue').addEventListener('change', (e) => { engineConfig.autohue = e.target.checked; syncUiToState(); });
        document.getElementById('input-mmode').addEventListener('change', (e) => { engineConfig.mmode = e.target.value; syncUiToState(); });
        document.getElementById('input-bgstyle').addEventListener('change', (e) => { engineConfig.bgstyle = e.target.value; syncUiToState(); });
        document.getElementById('input-heartStyle').addEventListener('change', (e) => { engineConfig.heartStyle = e.target.value; updateVisualMood('hearts'); });
        
        document.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'm') { engineConfig.uiVisible = !engineConfig.uiVisible; syncUiToState(); } });

        function startAnimationLoop() {
            animationTime++;
            if (engineConfig.autohue) { engineConfig.hue = (engineConfig.hue + 0.5) % 360; refreshUiColor(); synchronizeUrlParameters(); }
            
            drawContext.clearRect(0, 0, viewWidth, viewHeight);
            
            const isSpace = (engineConfig.mood === 'space' || (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'space'));
            const isMatrix = (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'matrix');
            
            if (engineConfig.bgstyle === 'black' || engineConfig.mood === 'space' || isMatrix) {
                drawContext.globalCompositeOperation = 'source-over';
                let trailAlpha = (engineConfig.mood === 'space') ? Math.max(0.05, 0.2 - (engineConfig.speed / 100)) : 0.25;
                drawContext.fillStyle = `rgba(0, 0, 0, ${trailAlpha})`;
                drawContext.fillRect(0, 0, viewWidth, viewHeight);
                
                if (engineConfig.mood === 'space' || (engineConfig.mood === 'hearts' && engineConfig.heartStyle === 'space')) {
                    starArray.forEach(s => { s.update(); s.draw(); });
                }
            }

            elementArray.forEach(el => { el.updatePhysics(); el.renderToCanvas(); });
            requestAnimationFrame(startAnimationLoop);
        }

        function handleWindowResize() { viewWidth = renderCanvas.width = window.innerWidth; viewHeight = renderCanvas.height = window.innerHeight; generateElementPool(); }
        window.addEventListener('resize', handleWindowResize); handleWindowResize(); 
        
        loadFromUrl();
        syncUiToState(); 
        updateVisualMood(engineConfig.mood); 
        startAnimationLoop();
    </script>
</body>
</html>